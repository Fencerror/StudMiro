import { Stage, Layer, Rect, Circle, Text } from "react-konva";
import { useState, useRef, SetStateAction } from "react";

interface BoardCanvasProps {
  selectedTool: "select" | "rectangle" | "circle" | "text";
  selectedColor: string;
}

interface RectangleShape {
  id: number;
  type: "rectangle";
  x: number;
  y: number;
  width: number;
  height: number;
  fill: string;
}
interface CircleShape {
  id: number;
  type: "circle";
  x: number;
  y: number;
  radius: number;
  fill: string;
}
interface TextShape {
  id: number;
  type: "text";
  x: number;
  y: number;
  text: string;
}
type Shape = RectangleShape | CircleShape | TextShape;

export default function BoardCanvas({ selectedTool, selectedColor }: BoardCanvasProps) {
  // States for shapes (separate arrays maintained for dragging updates)
  const [rectangles, setRectangles] = useState<Omit<RectangleShape, "type">[]>([]);
  const [circles, setCircles] = useState<Omit<CircleShape, "type">[]>([]);
  const [texts, setTexts] = useState<Omit<TextShape, "type">[]>([]);
  const [selectedIds, setSelectedIds] = useState<number[]>([]);
  const [drawing, setDrawing] = useState(false);
  const [newRect, setNewRect] = useState<{ x: number; y: number; width: number; height: number } | null>(null);
  const [newCircle, setNewCircle] = useState<{ x: number; y: number; radius: number } | null>(null);
  const [selectionRect, setSelectionRect] = useState<{ x: number; y: number; width: number; height: number } | null>(null);
  const [editingText, setEditingText] = useState<{ x: number; y: number; value: string } | null>(null);
  const stageRef = useRef<any>(null);
  const nextShapeId = useRef(1); // global shape id counter

  // Начинаем рисование или выделение
  const handleMouseDown = () => {
    if (drawing) return;
    setDrawing(true);

    const stage = stageRef.current;
    const pos = stage.getPointerPosition();

    if (selectedTool === "rectangle") {
      setNewRect({ x: pos.x, y: pos.y, width: 0, height: 0 });
    } else if (selectedTool === "circle") {
      setNewCircle({ x: pos.x, y: pos.y, radius: 0 });
    } else if (selectedTool === "select") {
      setSelectionRect({ x: pos.x, y: pos.y, width: 0, height: 0 });
    }
  };

  // Изменяем размер фигуры или рамки выделения
  const handleMouseMove = () => {
    if (!drawing) return;

    const stage = stageRef.current;
    const pos = stage.getPointerPosition();

    if (selectedTool === "rectangle" && newRect) {
      setNewRect({
        x: newRect.x,
        y: newRect.y,
        width: pos.x - newRect.x,
        height: pos.y - newRect.y,
      });
    } else if (selectedTool === "circle" && newCircle) {
      const radius = Math.sqrt(Math.pow(pos.x - newCircle.x, 2) + Math.pow(pos.y - newCircle.y, 2));
      setNewCircle({
        x: newCircle.x,
        y: newCircle.y,
        radius,
      });
    } else if (selectedTool === "select" && selectionRect) {
      setSelectionRect({
        x: selectionRect.x,
        y: selectionRect.y,
        width: pos.x - selectionRect.x,
        height: pos.y - selectionRect.y,
      });
    }
  };

  // Завершаем рисование или выделение
  const handleMouseUp = () => {
    if (!drawing) return;
    setDrawing(false);

    if (selectedTool === "rectangle" && newRect) {
      const id = nextShapeId.current++;
      setRectangles([...rectangles, { id, x: newRect.x, y: newRect.y, width: newRect.width, height: newRect.height, fill: selectedColor }]);
      setNewRect(null);
    } else if (selectedTool === "circle" && newCircle) {
      const id = nextShapeId.current++;
      setCircles([...circles, { id, x: newCircle.x, y: newCircle.y, radius: newCircle.radius, fill: selectedColor }]);
      setNewCircle(null);
    } else if (selectedTool === "select" && selectionRect) {
      const selected: SetStateAction<number[]> = [];
      const selectionBox = {
        x1: selectionRect.x,
        y1: selectionRect.y,
        x2: selectionRect.x + selectionRect.width,
        y2: selectionRect.y + selectionRect.height,
      };

      rectangles.forEach((rect) => {
        if (
          rect.x >= selectionBox.x1 &&
          rect.y >= selectionBox.y1 &&
          rect.x + rect.width <= selectionBox.x2 &&
          rect.y + rect.height <= selectionBox.y2
        ) {
          selected.push(rect.id);
        }
      });

      circles.forEach((circle) => {
        if (
          circle.x - circle.radius >= selectionBox.x1 &&
          circle.y - circle.radius >= selectionBox.y1 &&
          circle.x + circle.radius <= selectionBox.x2 &&
          circle.y + circle.radius <= selectionBox.y2
        ) {
          selected.push(circle.id);
        }
      });

      texts.forEach((text) => {
        if (
          text.x >= selectionBox.x1 &&
          text.y >= selectionBox.y1 &&
          text.x + 100 <= selectionBox.x2 && 
          text.y + 20 <= selectionBox.y2
        ) {
          selected.push(text.id);
        }
      });

      setSelectedIds(selected);
      setSelectionRect(null);
    }
  };

  // Обновлённый обработчик двойного клика для inline-редактирования текста
  const handleDoubleClick = () => {
    if (selectedTool !== "text") return;

    const stage = stageRef.current;
    const pos = stage.getPointerPosition();
    setEditingText({ x: pos.x, y: pos.y, value: "" });
  };

  // Обработка выделения элементов
  const handleSelect = (id: number) => {
    if (selectedTool !== "select") return;

    setSelectedIds((prevSelectedIds) => {
      if (prevSelectedIds.includes(id)) {
        return prevSelectedIds.filter((selectedId) => selectedId !== id);
      } else {
        return [...prevSelectedIds, id];
      }
    });
  };

  // Удаление выделенных элементов
  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === "Delete") {
      setRectangles((prevRectangles) => prevRectangles.filter((rect) => !selectedIds.includes(rect.id)));
      setCircles((prevCircles) => prevCircles.filter((circle) => !selectedIds.includes(circle.id)));
      setTexts((prevTexts) => prevTexts.filter((text) => !selectedIds.includes(text.id)));
      setSelectedIds([]);
    }
  };

  // Перемещение выделенных элементов
  const handleDragMove = (e: any, id: number, type: "rectangle" | "circle" | "text") => {
    const pos = e.target.position();

    if (type === "rectangle") {
      setRectangles((prev) => prev.map(rect => rect.id === id ? { ...rect, x: pos.x, y: pos.y } : rect));
    } else if (type === "circle") {
      setCircles((prev) => prev.map(circle => circle.id === id ? { ...circle, x: pos.x, y: pos.y } : circle));
    } else if (type === "text") {
      setTexts((prev) => prev.map(text => text.id === id ? { ...text, x: pos.x, y: pos.y } : text));
    }
  };

  // Upon text edit blur, add new text shape with a global id.
  const handleTextBlur = () => {
    if (editingText && editingText.value.trim()) {
      const id = nextShapeId.current++;
      setTexts([...texts, { id, x: editingText.x, y: editingText.y, text: editingText.value }]);
    }
    setEditingText(null);
  };

  // Combine all shapes into one array sorted by creation order
  const allShapes: Shape[] = [
    ...rectangles.map(r => ({ ...r, type: "rectangle" as const })),
    ...circles.map(c => ({ ...c, type: "circle" as const })),
    ...texts.map(t => ({ ...t, type: "text" as const }))
  ].sort((a, b) => a.id - b.id);

  return (
    <>
      <Stage
        ref={stageRef}
        width={window.innerWidth}
        height={window.innerHeight}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onDblClick={handleDoubleClick}
        onKeyDown={handleKeyDown}
        tabIndex={0}
        style={{ background: "#f5f5f5", zIndex: 1 }}
      >
        <Layer>
          {allShapes.map(shape => {
             if (shape.type === "rectangle") {
               return (
                 <Rect
                   key={shape.id}
                   x={shape.x}
                   y={shape.y}
                   width={shape.width}
                   height={shape.height}
                   fill={shape.fill}
                   stroke="black"
                   draggable={true}
                   onClick={() => handleSelect(shape.id)}
                   onDragMove={(e) => handleDragMove(e, shape.id, "rectangle")}
                 />
               );
             } else if (shape.type === "circle") {
               return (
                 <Circle
                   key={shape.id}
                   x={shape.x}
                   y={shape.y}
                   radius={shape.radius}
                   fill={shape.fill}
                   stroke="black"
                   draggable={true}
                   onClick={() => handleSelect(shape.id)}
                   onDragMove={(e) => handleDragMove(e, shape.id, "circle")}
                 />
               );
             } else if (shape.type === "text") {
               return (
                 <Text
                   key={shape.id}
                   x={shape.x}
                   y={shape.y}
                   text={shape.text}
                   fontSize={20}
                   fill="black"
                   draggable={true}
                   onClick={() => handleSelect(shape.id)}
                   onDragMove={(e) => handleDragMove(e, shape.id, "text")}
                 />
               );
             }
             return null;
          })}
          {newRect && <Rect x={newRect.x} y={newRect.y} width={newRect.width} height={newRect.height} fill="rgba(0, 0, 255, 0.3)" />}
          {newCircle && <Circle x={newCircle.x} y={newCircle.y} radius={newCircle.radius} fill="rgba(0, 0, 255, 0.3)" />}
          {selectionRect && (
            <Rect
              x={selectionRect.x}
              y={selectionRect.y}
              width={selectionRect.width}
              height={selectionRect.height}
              fill="rgba(0, 0, 255, 0.3)"
            />
          )}
        </Layer>
      </Stage>
      {editingText && (
        <textarea
          autoFocus
          style={{
            position: "absolute",
            top: editingText.y,
            left: editingText.x,
            fontSize: "20px",
            padding: "4px",
            borderRadius: "4px",
            border: "1px solid black",
            color: "black",
            zIndex: 3,
            transform: "translate(-50%, -50%)",
          }}
          value={editingText.value}
          onChange={(e) => setEditingText({ ...editingText, value: e.target.value })}
          onBlur={handleTextBlur}
          onKeyDown={(e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              handleTextBlur();
            } else if (e.key === "Escape") {
              setEditingText(null);
            }
          }}
        />
      )}
    </>
  );
}